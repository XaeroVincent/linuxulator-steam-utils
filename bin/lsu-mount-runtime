#!/usr/bin/env ruby
# encoding: UTF-8

require 'fileutils'
require_relative '.dpkgs'
require_relative '.utils'

SLR_NAME_OR_PATH = ARGV[0] || 'SteamLinuxRuntime_sniper'

reqs = []

EMUL_PATH = File.realdirpath(`sysctl -qn compat.linux.emul_path`).chomp
if not EMUL_PATH =~ /\/compat\/\w[\w\d]*/
  reqs << "This script doesn't like your compat.linux.emul_path."
end

SLR_DIR = File.basename(SLR_NAME_OR_PATH)
if not SLR_DIR =~ /SteamLinuxRuntime_\w+/
  reqs << "Expected the directory name starting with SteamLinuxRuntime_."
end

if `sysctl -nq vfs.usermount`.to_i != 1
  reqs << "This script requires vfs.usermount=1."
end

if not system('kldstat -q -m nullfs')
  reqs << "nullfs.ko must be loaded."
end

steam_linux_runtime_path = SLR_NAME_OR_PATH.start_with?('/') ? SLR_NAME_OR_PATH : find_steamapp_dir(SLR_DIR)
if not steam_linux_runtime_path
  reqs << "Can't find #{SLR_DIR}."
end

if reqs.size > 0
  for msg in reqs
    STDERR.puts msg
  end
  exit(1)
end

platform = Dir[File.join(steam_linux_runtime_path, "#{SLR_DIR.delete_prefix('SteamLinuxRuntime_')}_platform_*")]
  .sort.find{|dir| File.exist?(File.join(dir, 'metadata'))}
raise if not platform

download_debs(DPKGS, LSU_DIST_PATH)

init_tmp_dir()
mroot = File.join(LSU_TMPDIR_PATH, SLR_DIR)
FileUtils.mkdir_p(mroot)

#TODO: STEAM_COMPAT_* env vars
mounts = []
if try_mount('tmpfs', 'tmpfs', mroot, 'nocover')
  mounts << mroot
  begin
    # SteamLinuxRuntime
    FileUtils.mkdir_p(File.join(mroot, 'usr'))
    system('sh', '-c', 'set -o pipefail && tar --cd "$0" -c @../usr-mtree.txt.gz | tar --cd "$1" -x', '-',
      File.join(platform, 'files'), File.join(mroot, 'usr')) || raise
    system('chmod', '-R', 'u+rwX', mroot) || raise

    FileUtils.mv(File.join(mroot, 'usr/etc'), File.join(mroot, 'etc')) # ?

    # additional packages we'd like to have
    for pkgs in DPKGS.partition{|e| e[0] =~ /i386\.deb$/}
      extract_debs(pkgs, LSU_DIST_PATH, mroot)
    end

    FileUtils.ln_s('usr/bin', File.join(mroot, 'bin')) # ?

    # basic mount point setup
    mounts << mount('linprocfs', 'linprocfs', File.join(mroot, 'proc'))
    mounts << mount('linsysfs',  'linsysfs',  File.join(mroot, 'sys'))
    mounts << mount('nullfs',    '/tmp',      File.join(mroot, 'tmp'))     # X11
    mounts << mount('nullfs',    '/var/run',  File.join(mroot, 'var/run')) # Wayland (?)

    # we can't mount fd and shm over devfs from a non-root user, hence the symlink abuse below
    mounts << mount('devfs', 'devfs', File.join(mroot, 'dev/.dev'))

    # mounting fdescfs at /dev/fd (vs /compat/linux/dev/fd) apparently bothers CEF:
    # [xxxx/xxxxxx.xxxxxx:FATAL:proc_util.cc(97)] Check failed: . : No such file or directory (2)
    # mounts << mount('fdescfs', 'fdescfs', File.join(mroot, 'dev/fd'), 'linrdlnk')

    mounts << mount('nullfs', File.join(EMUL_PATH, 'dev/shm'), File.join(mroot, 'dev/shm'))

    Dir.chdir(File.join(mroot, 'dev')) do
      for path in Dir['.dev/*']
        basename = File.basename(path)
        FileUtils.ln_s(path, basename) if !File.exist?(basename)
      end
      FileUtils.ln_s('.dev/dsp',   'dsp')
      FileUtils.ln_s('.dev/mixer', 'mixer')
    end

    # basic configuration
    FileUtils.cp('/etc/group',       File.join(mroot, 'etc/'))
    FileUtils.cp('/etc/hosts',       File.join(mroot, 'etc/'))
    FileUtils.cp('/etc/machine-id',  File.join(mroot, 'etc/')) # dbus
    FileUtils.cp('/etc/passwd',      File.join(mroot, 'etc/')) # getpwuid_r()
    FileUtils.cp('/etc/resolv.conf', File.join(mroot, 'etc/')) # dns

    # LSU's bin/lib dirs
    lsu_dir = File.realpath(File.join(__dir__, '..'))
    mounts << mount('nullfs', lsu_dir, File.join(mroot, LSU_IN_CHROOT))

    # Nvidia libs
    for source_dir, dest_dir in {
      File.join(EMUL_PATH, 'usr/lib64') => File.join(mroot, 'usr/lib/x86_64-linux-gnu'),
      File.join(EMUL_PATH, 'usr/lib')   => File.join(mroot, 'usr/lib/i386-linux-gnu')
    }
      libs = Dir[File.join(source_dir, 'lib{nvidia-*.so*,EGL_nvidia.so*,GLX_nvidia.so*}')]
      if libs.size > 0
        mounts << mount('nullfs', source_dir, File.join(dest_dir, '.nvidia'))
        for path in libs
          FileUtils.ln_s(File.join('.nvidia', File.basename(path)), File.join(dest_dir, File.basename(path)))
        end
      end
    end

    if File.exist?('/usr/local/share/vulkan/icd.d/nvidia_icd.json')
      FileUtils.cp('/usr/local/share/vulkan/icd.d/nvidia_icd.json', File.join(mroot, 'etc/vulkan/icd.d/'))
    end

    # fonts
    mounts << mount('nullfs', '/usr/local/share/fonts', File.join(mroot, 'usr/share/fonts'), 'union')

    # sound
    FileUtils.rm_r(File.join(mroot, 'etc/alsa'))
    FileUtils.cp(File.join(EMUL_PATH, 'etc/asound.conf'), File.join(mroot, 'etc/'))
    FileUtils.cp(File.join(EMUL_PATH, 'usr/lib64/alsa-lib/libasound_module_ctl_oss.so'), File.join(mroot, 'usr/lib/x86_64-linux-gnu/alsa-lib/'))
    FileUtils.cp(File.join(EMUL_PATH, 'usr/lib64/alsa-lib/libasound_module_pcm_oss.so'), File.join(mroot, 'usr/lib/x86_64-linux-gnu/alsa-lib/'))
    FileUtils.cp(File.join(EMUL_PATH, 'usr/lib/alsa-lib/libasound_module_ctl_oss.so'),   File.join(mroot, 'usr/lib/i386-linux-gnu/alsa-lib/'))
    FileUtils.cp(File.join(EMUL_PATH, 'usr/lib/alsa-lib/libasound_module_pcm_oss.so'),   File.join(mroot, 'usr/lib/i386-linux-gnu/alsa-lib/'))
    mounts << mount('nullfs', File.join(EMUL_PATH, 'usr/share/alsa'), File.join(mroot, 'usr/share/alsa'))

    # glxgears
    if File.exist?(File.join(EMUL_PATH, 'bin/glxgears'))
      FileUtils.cp(File.join(EMUL_PATH, 'bin/glxgears'), File.join(mroot, 'usr/bin/'))
    end

    # eON workaround
    #~ for i in 0..64 do
      #~ FileUtils.mkdir_p(File.join(mroot, EMUL_PATH, "sys/devices/system/cpu/cpu#{i}/topology/")) # ?
      #~ File.write(File.join(mroot, EMUL_PATH, "sys/devices/system/cpu/cpu#{i}/topology/core_id"), i.to_s)
    #~ end

    # $HOME, $STEAM_COMPAT_LIBRARY_PATHS, $STEAM_COMPAT_MOUNTS
    HIER_HOME_PATH = /^(\/usr|)\/home\/[^\/]+/
    RESERVED_PATHS = /^\/(app|bin|boot|compat|dev|etc|lib(32|64|exec|)|proc|rescue|root|run|sbin|sys|tmp|usr|var|zroot)\/?/

    def try_mount_user_dir(mroot, path)
      if path.start_with?('/')
        path = File.realpath(path)
        if path =~ HIER_HOME_PATH || !(path =~ RESERVED_PATHS)
          target = File.join(mroot, path.gsub(/^\/usr\/home\//, '/home/'))
          try_mount('nullfs', path, target, 'nocover')
        else
          STDERR.puts "skipping #{path.inspect}, path is not allowed"
          nil
        end
      else
        STDERR.puts "skipping #{path.inspect}, expected an absolute path"
        nil
      end
    end

    home_dir = File.realpath(ENV['HOME'])
    raise if !(home_dir =~ HIER_HOME_PATH)
    home_dir_mount = try_mount_user_dir(mroot, home_dir)
    raise if !home_dir_mount
    mounts << home_dir_mount

    FileUtils.ln_s('../home', File.join(mroot, 'usr/home'))

    lsu_tmp_dir = File.realpath(LSU_TMPDIR_PATH)
    home_mounts = JSON.parse(`mount --libxo json`)['mount']['mounted']
      .map     {|m| m['node']}
      .find_all{|path| path.start_with?(home_dir) && path != home_dir && !path.start_with?(lsu_tmp_dir)}
      .sort
    for dir in home_mounts
      path = try_mount_user_dir(mroot, dir)
      mounts << path if path
    end

    #TODO: this doesn't really work due to chroot being shared with steamwebhelper
    if ENV['STEAM_COMPAT_LIBRARY_PATHS']
      for dir in ENV['STEAM_COMPAT_LIBRARY_PATHS'].split(':')
        path = try_mount_user_dir(mroot, dir)
        mounts << path if path
      end
    end

    if ENV['STEAM_COMPAT_MOUNTS']
      for dir in ENV['STEAM_COMPAT_MOUNTS'].split(':')
        path = try_mount_user_dir(mroot, dir)
        mounts << path if path
      end
    end
  rescue
    for path in mounts.reverse
      system('umount', '-f', path)
    end
    raise
  end
else
  STDERR.puts "Assuming #{mroot} is already set up."
end
